{"version":3,"names":[],"mappings":"","sources":["provider/core.js"],"sourcesContent":["import promise from 'promise-callback';\nimport _ from 'lodash';\n\nimport profile from '../profile';\n\nrequire('traceur-runtime');\n\nmodule.exports = API => {\n  const credentials = {};\n\n  const credentialSchema = {\n    token: {\n      type: 'string',\n      header: 'Personal Access Token',\n      link: 'https://cloud.digitalocean.com/settings/tokens/new',\n      required: true,\n      environmentVariable: 'DO_TOKEN'\n    }\n  };\n\n  return {\n    name: 'digitalocean',\n    targets: ['coreos'],\n    api: digitalocean(API, credentials),\n    $rawAPI: API,\n    profile,\n    credentials,\n    credentialSchema,\n    dashboardUrl: 'https://cloud.digitalocean.com',\n    referralUrl: 'https://www.digitalocean.com/?refcode=4df1a6f6f727',\n    referralTeaser: 'Signup for a DigitalOcean account through this referral link to get $10 in free credits and to support cloud-launcher.'\n  };\n};\n\nfunction digitalocean(API, credentials) {\n  const status = {\n    limit: undefined,         //API Rate Limit (per hour?)\n    remaining: undefined,     //API Calls Left\n    resetTime: undefined,     //When API Rate Calls will reset (datetime)\n    machineLimit: undefined   //Number of machines digitalocean allows you to create\n  };\n\n  return {\n    createMachine,\n    destroyMachine,\n\n    listMachines,\n\n    verifyAccount,\n\n    status,\n\n    MAX_CONCURRENT_CALLS: 5\n  };\n\n  function createMachine(description) {\n    const api = getApi(),\n          {id, location, size, image, keys, userData} = description;\n\n    return promise(\n      api.dropletsCreateNewDroplet.bind(api),\n      id, location, size, image, {ssh_keys: keys, user_data: userData}\n    )\n    .then(handleApiResponse, handleApiError)\n    .then(value => {\n      const [data, header, response] = value,\n            {droplet} = data,\n            doIdentifier = {\n              id: droplet.id,\n              createdAt: droplet.created_at\n            };\n\n      return doIdentifier;\n    });\n  }\n\n  function destroyMachine(machine) {\n    var api = getApi();\n\n    return promise(\n      api.dropletsDeleteDroplet.bind(api),\n      machine.response.id\n    )\n    .then(handleApiResponse)\n    .then(value => {\n      return {success: true};\n    });\n  }\n\n  function listMachines() {\n    const api = getApi();\n\n    return promise(\n      api.dropletsGetAll.bind(api)\n    )\n    .then(handleApiResponse)\n    .then(value => {\n      const [data] = value,\n            {droplets} = data;\n\n      return _.reduce(droplets, (result, droplet) => {\n        const {id, created_at: createdAt, name, networks, status} = droplet;\n\n        result[name] = {\n          id,\n          createdAt,\n          networks: {\n            v4: _.map(networks.v4, network => {\n              const {ip_address: ipAddress, netmask, gateway, type} = network;\n              return {ipAddress, netmask, gateway, type};\n            }),\n            v6: networks.v6\n          },\n          status\n        };\n\n        return result;\n      }, {});\n    });\n  }\n\n  function verifyAccount() {\n    const api = getApi();\n\n    return promise(\n      api.account.bind(api)\n    )\n    .then(handleApiResponse)\n    .then(value => {\n      const [data] = value;\n\n      status.machineLimit = data.account.droplet_limit;\n    });\n  }\n\n  function getApi() {\n    return new API(credentials.token, 1000);\n  }\n\n  function handleApiResponse(value) {\n    return new Promise((resolve, reject) => {\n      let data, response;\n\n      if (Array.isArray(value)) [data, response] = value;\n      else data = response = value;\n\n      response = response || data;\n\n      const headers = response.headers || getResponseHeaders(response, ['RateLimit-Limit', 'RateLimit-Remaining', 'RateLimit-Reset']);\n\n      status.limit = parseInt(headers['RateLimit-Limit'] || '0');\n      status.remaining = parseInt(headers['RateLimit-Remaining'] || '0');\n      status.reset = new Date(parseInt(headers['RateLimit-Reset'] || '0') * 1000);\n\n      resolve(value);\n    });\n  }\n\n  function handleApiError(value) {\n    return new Promise((resolve, reject) => {\n      const {error, args} = value;\n      let [data, response] = args;\n\n      response = response || data;\n\n      if (response.statusCode === 401) {\n        reject({error: 'Unauthorized', data, response, provider: digitalocean.$name});\n        return;\n      }\n      reject({error, data, response, provider: digitalocean.$name});\n    });\n  }\n\n  function getResponseHeaders(response, headers) {\n    return _.reduce(headers, (result, header) => {\n      result[header] = response.getResponseHeader(header);\n      return result;\n    }, {});\n  }\n}"],"file":"provider/core.js","sourceRoot":"/source/"}